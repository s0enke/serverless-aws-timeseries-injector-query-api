@startuml

!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Dynamic.puml

LAYOUT_LANDSCAPE()

!define AWSPuml https://raw.githubusercontent.com/awslabs/aws-icons-for-plantuml/v13.1/dist
!include AWSPuml/AWSCommon.puml
!include AWSPuml/General/all.puml
!include AWSPuml/Compute/all.puml
!include AWSPuml/Database/all.puml
!include AWSPuml/Storage/all.puml
!include AWSPuml/ApplicationIntegration/all.puml
!include AWSPuml/BusinessApplications/all.puml
!include AWSPuml/SecurityIdentityCompliance/all.puml

title "Serverless Timeseries injector and reader"

Boundary(B_DESCRIPTION, "<b>This proposes a serverless architecture for a timeseries injector and query API:</b>", "assd") {

}

Boundary(B_TS_DB, "Timeseries Database") {
  Timestream(TS_DB, "Timeseries DB", "")
  note right: use timestamp as version to always upsert and ensure latest data win
  note right: use magnetic store for long term storage
}

' TODO: panda_parse_args
Boundary(B_SENSOR_TENANT_DATA, "Sensor/Tenant Data") {
  DynamoDB(SENSORS_TABLE, "Sensors table", "Structure: [sensor_id, user_id, injector_id, injector_type, injector_data]")
  note right
   user_id maps to Cognito userpool
   a sensor(_id) might have more than one injector(_id)
  endnote
}

Boundary(B_RAW_DATA, "Raw data Storage and Parser") {
  SimpleStorageServiceBucket(RAW_DATA_BUCKET, "Raw data Bucket", "Structure: sensor_id/file_checksum", "")
  note right of RAW_DATA_BUCKET: checksum to ensure ignoring already existing data
  SimpleQueueServiceQueue(RAW_DATA_QUEUE, "Raw Data SQS Queue", "")
  SimpleQueueServiceQueue(RAW_DATA_DLQUEUE, "Dead letter queue", "")
  Rel(RAW_DATA_BUCKET, RAW_DATA_QUEUE, "emits event on new object",   "")

  Lambda(PARSER_FUNCTION, "Parser Function", "")
  note right
    detects format, e.g. JSON or CSV
    reads/writes with python pandas lib and aws-datawrangler
  endnote
  Rel(RAW_DATA_QUEUE, PARSER_FUNCTION, "reads message from queue",   "")
  Rel(PARSER_FUNCTION, RAW_DATA_BUCKET, "reads raw data", "")
  Rel(PARSER_FUNCTION, TS_DB, "insert timeseries data", "")
  Rel(RAW_DATA_QUEUE, RAW_DATA_DLQUEUE, "move to DLQ after N tries", "")

}

Boundary(B_INJECTORS, "Injectors") {

  Traditionalserver(PULL_SOURCE, "External source", "")

  Boundary(B_INJECTOR_PERIODIC, "Periodic (pull) Injector") {
    UpdateBoundaryStyle($bgColor="lightblue")
    UpdateRelStyle($lineColor="blue", $textColor="blue")
    StepFunctions(PULL_COORDINATOR, "Coordination State Machine", "")
    EventBridgeEvent(PERIODIC_SCHEDULER, "Scheduler", "")
    RelIndex(1, PERIODIC_SCHEDULER, PULL_COORDINATOR, "triggers every X minutes")
    RelIndex(2, PULL_COORDINATOR, SENSORS_TABLE, "reads injector_type=periodic")
    Lambda(PULL_FUNCTION, "Pull Function", "")
    RelIndex(3, PULL_COORDINATOR, PULL_FUNCTION, "calls for each injector")

    RelIndex(4, PULL_FUNCTION, PULL_SOURCE, "pulls data", "Additional logic per type, e.g. delete from FTP server once copied to S3")
    RelIndex(5, PULL_FUNCTION, RAW_DATA_BUCKET, "puts data")
  }

  actor User as UPLOADER
  Boundary(B_INJECTOR_UPLOAD, "HTTP Upload Injector") {
    UpdateBoundaryStyle($bgColor="lightpink")
    UpdateRelStyle($lineColor="red", $textColor="red")
    APIGatewayEndpoint(HTTP_UPLOAD_PRESIGNED_URL_ENDPOINT, "/gen-upload-url", "returns presigned URL for upload")
    Lambda(UPLOAD_AUTHORIZER, "Upload Authorizer", "")
    RelIndex(3, UPLOAD_AUTHORIZER, SENSORS_TABLE, "authorizes", "")
    RelIndex(4, UPLOAD_AUTHORIZER, RAW_DATA_BUCKET, "generates presigned URL", "")
    RelIndex(2, HTTP_UPLOAD_PRESIGNED_URL_ENDPOINT, UPLOAD_AUTHORIZER, "calls", "")

    RelIndex(1, UPLOADER, HTTP_UPLOAD_PRESIGNED_URL_ENDPOINT, "gets presigned upload URL")
    RelIndex(5, UPLOADER, RAW_DATA_BUCKET, "uploads data")
  }

  SimpleEmailServiceEmail(INCOMING_EMAILS, "Incoming emails", "")
  Boundary(B_INJECTOR_EMAIL, "Email Injector") {
    UpdateRelStyle($lineColor="green", $textColor="green")
    UpdateBoundaryStyle($bgColor="lightgreen")
    SimpleEmailService(SES_INCOMING, "Incoming email gateway", "")
    note right of SES_INCOMING: Format: incoming+<shared-secret>\n@sensor-injector.\nprod.example.com
    RelIndex(1, INCOMING_EMAILS, SES_INCOMING, "arrive at")
    Lambda(INCOMING_EMAILS_LAMBDA, "Incoming Mail handler", "")
    RelIndex(2, SES_INCOMING, INCOMING_EMAILS_LAMBDA, "calls", "")
    RelIndex(3, INCOMING_EMAILS_LAMBDA, SENSORS_TABLE, "authorizes", "")
    RelIndex(4, INCOMING_EMAILS_LAMBDA, RAW_DATA_BUCKET, "parses mail and puts raw into", "")
  }

}

actor User as CUSTOMER
Boundary(B_QUERY_API, "Timeseries Query API") {
  UpdateBoundaryStyle($bgColor="white")
  UpdateRelStyle($lineColor="black", $textColor="black")

  Cognito(USER_POOL, "User-Pool", "")
  APIGatewayEndpoint(LIST_SENSOR_DATA, "/ts/?sensor_id=abc", "list time series", GET)
  RelIndex(2, LIST_SENSOR_DATA, USER_POOL, "authorizes at", "via Cognito authorizer")
  RelIndex(1, CUSTOMER, LIST_SENSOR_DATA, "queries API")
  RelIndex(3, LIST_SENSOR_DATA, TS_DB, "queries", "via service integration")
}

newpage

Boundary(B_QUERY_API_TEST, "Timeseries Query API") {
  CognitoParticipant(USER_POOL_P, "User-Pool", "")
  actor User as CUSTOMER_
  USER_POOL_P -> CUSTOMER_

}

Lay_D(B_DESCRIPTION, B_INJECTORS)


@enduml